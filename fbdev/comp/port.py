"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/00_comp/01_port.ipynb.

# %% ../../nbs/api/00_comp/01_port.ipynb 4
from __future__ import annotations
import asyncio
from enum import Enum
from typing import List, Dict, Callable, Any, Tuple, Iterator, Type
from types import MappingProxyType
from abc import ABC, abstractmethod

import fbdev
from .packet import BasePacket, Packet
from .._utils import SingletonMeta, AttrContainer, StateHandler, StateCollection, is_valid_name, EventCollection, EventHandler, abstractproperty

# %% auto 0
__all__ = ['PortID', 'PortType', 'PortSpec', 'PortSpecCollection', 'BasePort', 'Port', 'PortCollection']

# %% ../../nbs/api/00_comp/01_port.ipynb 6
class PortType(Enum):
    INPUT = ("input", True)
    CONFIG = ("config", True)
    SIGNAL = ("signal", True)
    
    OUTPUT = ("output", False)
    MESSAGE = ("message", False)
    
    def __init__(self, label:str, is_input_port:bool):
        self._label:str = label
        self._is_input_port:bool = is_input_port
        
    @property
    def label(self) -> str: return self._label
    @property
    def is_input_port(self) -> bool: return self._is_input_port
    
    def get(self, port_type_label:str) -> PortType:
        for port_type in self:
            if port_type.label == port_type_label:
                return port_type
        raise RuntimeError(f"Port type {port_type_label} does not exist.")

# %% ../../nbs/api/00_comp/01_port.ipynb 7
PortID = Tuple[PortType, str]

# %% ../../nbs/api/00_comp/01_port.ipynb 9
class PortSpec:
    _NO_DEFAULT = type(None)
    
    def __init__(self, port_type, name=None, dtype=None, data_validator=None, is_optional=False, default=_NO_DEFAULT):
        self._name:str = name
        self._port_type:PortType = port_type
        self._dtype:type = dtype
        self._data_validator:Callable[[Any], bool] = data_validator
        self._is_optional = is_optional
        self._default = default
        
        if dtype is not None and type(dtype) != type:
            raise ValueError("Argument `dtype` must be a type")
        
        if port_type == PortType.SIGNAL:
            if dtype is not None: raise RuntimeError(f"Signal port {self.name} cannot have a dtype.")
            if data_validator is not None: raise RuntimeError(f"Signal port {self.name} cannot have a data validator.")
        
        if port_type != PortType.CONFIG:
            if is_optional:
                raise RuntimeError(f"Only ports of type {PortType.CONFIG} can be optional.")
            if self.has_default:
                raise RuntimeError(f"Only ports of type {PortType.CONFIG} can have a default value.")
        
        if self.is_optional and self.has_default:
            raise RuntimeError("Config port {self.name} cannot have both be optional and have a default value.")
            
    @property
    def name(self) -> str: return self._name
    @property
    def id(self) -> PortID: return (self._port_type, self._name)
    @property
    def id_str(self) -> PortID: return f"{self._port_type.label}.{self._name}"
    @property
    def port_type(self) -> PortType: return self._port_type
    @property
    def is_input_port(self) -> bool: return self._port_type.is_input_port
    @property
    def is_output_port(self) -> bool: return not self.is_input_port
    @property
    def dtype(self) -> type: return self._dtype
    @property
    def data_validator(self) -> Callable[[Any], bool]: return self._data_validator
    
    @property
    def has_dtype(self) -> bool: return self._dtype is not None
    @property
    def has_data_validator(self) -> bool: return self._data_validator is not None
    
    @property
    def is_optional(self) -> bool: return self._is_optional
    @property
    def default(self) -> Any:
        if not self.has_default: raise RuntimeError(f"Config port {self.name} does not have a default value.")
        return self._default
    @property
    def has_default(self) -> bool: return self._default != PortSpec._NO_DEFAULT
    
    def __str__(self) -> str:
        return f"{self.port_type.label}.{self.name}"
    
    def __repr__(self) -> str:
        return str(self)

    def copy(self):
        if self.has_default:
            port_spec = PortSpec(
                self._port_type,
                self._name,
                self._dtype,
                self._data_validator,
                self._is_optional,
                self._default
            )
        else:
            port_spec = PortSpec(
                self._port_type,
                self._name,
                self._dtype,
                self._data_validator,
                self._is_optional
            )
        return port_spec

# %% ../../nbs/api/00_comp/01_port.ipynb 11
class PortSpecCollection:
    def __init__(self, *port_specs:List[PortSpec]):
        self._readonly:bool = False
        self._ports: Dict[PortID, PortSpec] = {}
        for port_type in PortType:
            setattr(self, port_type.label, AttrContainer({}, obj_name=f"{PortSpecCollection.__name__}.{port_type.label}"))
        for port_spec in port_specs:
            if port_spec.name is None: raise ValueError("PortSpec.name is None.")
            if not isinstance(port_spec, PortSpec): raise TypeError(f"PortSpecCollection can only contain PortSpecs. Got '{type(port_spec)}'.")
            self.add_port(port_spec)
    
    def __getitem__(self, key:PortID) -> PortSpec:
        if key in self._ports: return self._ports[key]
        else: raise KeyError(f"'{key}' does not exist in {self.__class__.__name__}.")
    
    def __iter__(self): return self._ports.__iter__()
    def __len__(self): return self._ports.__len__()
    def __contains__(self, key): return key in self._ports
    def as_dict(self) -> Dict[str, PortSpec]: return MappingProxyType(self._ports)
    def iter_ports(self) -> Iterator[PortSpec]: return self._ports.values()
    
    def make_readonly(self): self._readonly = True
    
    def add_port(self, port_spec:PortSpec):
        if self._readonly: raise RuntimeError("Cannot add ports to a readonly PortSpecCollection.")
        if not is_valid_name(port_spec.name): raise ValueError(f"Invalid port name '{port_spec.name}'.")
        if port_spec.id in self._ports: raise ValueError(f"Port name '{port_spec.name}' already exists in {self.__class__.__name__}.")
        self._ports[port_spec.id] = port_spec
        
        name_parts = port_spec.name.split('.')
        name_stem = name_parts.pop()
        attr_container = getattr(self, port_spec.port_type.label)
        attr_container_addr = f"{PortSpecCollection.__name__}.{port_spec.port_type.label}"
        for name_part in name_parts:
            attr_container_addr += f".{name_part}"
            if not name_part in attr_container:
                attr_container._set(name_part, AttrContainer({}, obj_name=attr_container_addr))
            attr_container = attr_container[name_part]
        attr_container._set(name_stem, port_spec)
    
    def remove_port(self, port_spec:PortSpec):
        if self._readonly: raise RuntimeError("Cannot remove ports from a readonly PortSpecCollection.")
        if port_spec.id not in self._ports: raise ValueError(f"Port name '{port_spec.name}' does not exist in {self.__class__.__name__}.")
        del self._ports[port_spec.id]
        getattr(self, port_spec.port_type.label)._remove(port_spec.name)
        
    def clear_all_ports(self):
        if self._readonly: raise RuntimeError("Cannot remove ports from a readonly PortSpecCollection.")
        for port_spec in self._ports.values():
            self.remove_port(port_spec)
        
    def update(self, parent:PortSpecCollection):
        if self._readonly: raise RuntimeError("Cannot add ports to a readonly PortSpecCollection.")
        for port in parent._ports.values():
            self.add_port(port)
        
    def copy(self) -> PortSpecCollection:
        """Note: The copy is not readonly."""
        port_spec_collection = PortSpecCollection(
            *[port_spec.copy() for port_spec in self._ports.values()]
        )
        return port_spec_collection
        
    def __str__helper(self, attr_container:AttrContainer, lines:List[str], indent:str=''):
        for key, value in attr_container.items():
            if isinstance(value, AttrContainer):
                lines.append(f"{indent}{key}:")
                self.__str__helper(value, lines, indent + "  ")
            else: lines.append(f"{indent}{key}")
        
    def __str__(self) -> str:
        lines = []
        for port_type in PortType:
            if len(getattr(self, port_type.label)) == 0: continue
            lines.append(f"{port_type.label}:")
            self.__str__helper(getattr(self, port_type.label), lines, "  ")
        return "\n".join(lines)
    
    def __repr__(self):
        return self.__str__()
    

# %% ../../nbs/api/00_comp/01_port.ipynb 14
class BasePort(ABC):
    @abstractproperty
    def spec(self) -> PortSpec: ...
    @abstractproperty
    def name(self) -> str: ...
    @abstractproperty
    def id(self) -> str: ...
    @abstractproperty
    def port_type(self) -> PortType: ...
    @abstractproperty
    def dtype(self) -> type: ...
    @abstractproperty
    def is_input_port(self) -> bool: ...
    @abstractproperty
    def is_output_port(self) -> bool: ...
    @abstractproperty
    def data_validator(self) -> Callable[[Any], bool]: ...
    @abstractproperty
    def states(self) -> StateCollection: ...
    @abstractproperty
    def events(self) -> EventCollection: ...
        
    @abstractmethod
    async def _put(self, packet:BasePacket): ...
    
    @abstractmethod
    async def _get(self) -> BasePacket: ...
    
    async def _put_value(self, val:Any):
        await self._put(Packet(val))
        
    async def _get_and_consume(self) -> Any:
        packet: BasePacket = await self._get()
        return await packet.consume()

# %% ../../nbs/api/00_comp/01_port.ipynb 16
class Port(BasePort):
    def __init__(self, port_spec:PortSpec):
        self._port_spec: PortSpec = port_spec
        self._name: str = port_spec.name
        self._id: str = port_spec.id
        self._port_type: PortType = port_spec.port_type
        self._is_input_port: bool = port_spec.is_input_port
        self._dtype: type = port_spec.dtype
        self._data_validator: Callable[[Any], bool] = port_spec.data_validator
        self._packet: BasePacket = None
        
        self._states = StateCollection()
        self._states._add_state(StateHandler("is_blocked", False)) # If input port, it's blocked if the component is currently getting. If output port, it's blocked if the component is currently putting.
        self._states._add_state(StateHandler("put_awaiting", False))
        self._states._add_state(StateHandler("get_awaiting", False))
        
        self._events = EventCollection()
        self._events._add_event(EventHandler("put_requested"))
        self._events._add_event(EventHandler("put_fulfilled"))
        self._events._add_event(EventHandler("get_requested"))
        self._events._add_event(EventHandler("get_fulfilled"))
        
        self._packet_queue = asyncio.Queue(maxsize=1)
        self._num_waiting_gets = 0
        self._num_waiting_puts = 0
        
        self._handshakes = asyncio.Queue()
        
        if self.is_input_port:
            self.get = self._get
            self.get_and_consume = self._get_and_consume
        else:
            self.put = self._put
            self.put_value = self._put_value
    
    @property
    def spec(self) -> PortSpec: return self._port_spec
    @property
    def name(self) -> str: return self._name
    @property
    def id(self) -> str: return self._id
    @property
    def port_type(self) -> PortType: return self._port_type
    @property
    def dtype(self) -> type: return self._dtype
    @property
    def is_input_port(self) -> bool: return self._is_input_port
    @property
    def is_output_port(self) -> bool: return not self.is_input_port
    @property
    def data_validator(self) -> Callable[[Any], bool]: return self._data_validator
    @property
    def states(self) -> StateCollection: return self._states
    @property
    def events(self) -> EventCollection: return self._events
        
    async def __initiate_handshake(self):
        handshake_received_event = asyncio.Event()
        await self._handshakes.put(handshake_received_event)
        await handshake_received_event.wait()
        
    async def __request_handshake(self):
        handshake_received_event = await self._handshakes.get()
        handshake_received_event.set()
        
    async def _put(self, packet:BasePacket):
        if not isinstance(packet, BasePacket): raise ValueError(f"`packet` is not of type `{BasePacket.__name__}`.")
        if packet.is_consumed: raise RuntimeError(f"Tried to put already-consumed packet: '{packet.uuid}'.")
        if self.is_output_port: self.states._is_blocked.set(True)
        self.events.put_requested._trigger()
        self._num_waiting_puts += 1
        self.states._put_awaiting.set(True)
        await self.__initiate_handshake()
        await self._packet_queue.put(packet)
        self._num_waiting_puts -= 1
        if self._num_waiting_puts == 0:
            self.states._put_awaiting.set(False)
            if self.is_output_port: self.states._is_blocked.set(False)
        self.events.put_fulfilled._trigger()
    
    async def _get(self) -> BasePacket:
        if self.is_input_port: self.states._is_blocked.set(True)
        self.events.get_requested._trigger()
        self.states._get_awaiting.set(True)
        self._num_waiting_gets += 1
        await self.__request_handshake()
        packet = await self._packet_queue.get()
        self._num_waiting_gets -= 1
        if self._num_waiting_gets == 0:
            self.states._get_awaiting.set(False)
            if self.is_input_port: self.states._is_blocked.set(False)
        self.events.get_fulfilled._trigger()
        if packet.is_consumed: raise RuntimeError(f"Got already-consumed packet: '{packet.uuid}'.")
        return packet

# %% ../../nbs/api/00_comp/01_port.ipynb 24
class PortCollection:
    def __init__(self, port_spec_collection:PortSpecCollection):
        self._port_spec_collection: PortSpecCollection = port_spec_collection
        self._ports: Dict[str, Port] = {}
        for port_type in PortType:
            setattr(self, port_type.label, AttrContainer({}, obj_name=f"{PortCollection.__name__}.{port_type.label}"))
        for port_spec in port_spec_collection.iter_ports():
            self._add_port(Port(port_spec))
    
    def _add_port(self, port:Port):
        if not is_valid_name(port.name): raise ValueError(f"Invalid port name '{port.name}'.")
        if port.id in self._ports: raise ValueError(f"Port name '{port.name}' already exists in {self.__class__.__name__}.")
        self._ports[port.id] = port
        
        name_parts = port.name.split('.')
        name_stem = name_parts.pop()
        attr_container = getattr(self, port.port_type.label)
        attr_container_addr = f"{PortSpecCollection.__name__}.{port.port_type.label}"
        for name_part in name_parts:
            attr_container_addr += f".{name_part}"
            if not name_part in attr_container:
                attr_container._set(name_part, AttrContainer({}, obj_name=attr_container_addr))
            attr_container = attr_container[name_part]
        attr_container._set(name_stem, port)
    
    def __getitem__(self, key:PortID) -> Port:
        if key in self._ports: return self._ports[key]
        else: raise KeyError(f"'{key}' does not exist in {self.__class__.__name__}.")
    
    def __iter__(self): return self._ports.__iter__()
    def __len__(self): return self._ports.__len__()
    def __contains__(self, key): return key in self._ports
    def as_dict(self) -> Dict[str, Port]: return MappingProxyType(self._ports)
    
    def iter_ports(self) -> Iterator[Port]: return self._ports.values().__iter__()

    def __str__(self): return self._port_spec_collection.__str__()
    
    def __repr__(self): return self._port_spec_collection.__repr__()
