"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/00_packet.ipynb.

# %% ../nbs/api/00_packet.ipynb 4
from __future__ import annotations
import asyncio
from typing import Any, Union, List, Hashable, Dict, Set, Tuple
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from types import MappingProxyType

import fbdev
from .utils import AddressableMixin

# %% auto 0
__all__ = ['NullPayload', 'Packet', 'PacketActivity', 'PacketCreation', 'PacketMovement', 'PacketRegistry', 'PacketHandler']

# %% ../nbs/api/00_packet.ipynb 6
class NullPayload:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(NullPayload, cls).__new__(cls)
        return cls._instance
    def __repr__(self):
        return "<NullPayload>"

# %% ../nbs/api/00_packet.ipynb 8
class Packet:
    def __init__(self, *, _data:Any, _id=None):
        self._id:Hashable = _id
        self._data:Any = _data
        self._dtype:type = type(_data)
            
    @property
    def id(self): return self._id
    @property
    def is_empty(self): return self._dtype == NullPayload
    @property
    def dtype(self): return self._dtype
    
    def get_deep_copy(self):
        pass

# %% ../nbs/api/00_packet.ipynb 10
class PacketActivity:
    def __init__(self, packet:Packet, timestamp: datetime = None):
        self.packet_id:Hashable = packet.id
        if timestamp is None: timestamp = datetime.now()  # TODO not timezone aware
        self.timestamp:datetime = timestamp

# %% ../nbs/api/00_packet.ipynb 12
class PacketCreation(PacketActivity):
    def __init__(self, packet:Packet, address, timestamp: datetime = None):
        super().__init__(packet, timestamp)
        self.packet_dtype:type = packet.dtype
        self.address:Tuple = address

# %% ../nbs/api/00_packet.ipynb 14
class PacketMovement(PacketActivity):
    def __init__(self, packet:Packet, origin:str, dest:str, port_type: fbdev.port.PortType, port_name: str, timestamp: datetime = None):
        super().__init__(packet, timestamp)
        self.origin:str = origin
        self.dest:str = dest
        self.port_type:fbdev.port.PortType = port_type
        self.port_name:str = port_name

# %% ../nbs/api/00_packet.ipynb 17
class PacketRegistry:
    def __init__(self): 
        self._packets:Dict[Hashable, Packet] = {}
        self._num_packets = 0
        self._consumed_packets:Set[Hashable] = set()
        self._locations:Dict[Packet, Tuple] = {}
        self._history: List[PacketActivity] = []
        
    @property
    def packets(self): return MappingProxyType(self._packets)
    @property
    def consumed_packets(self): return frozenset(self._consumed_packets)
    @property
    def locations(self): return MappingProxyType(self._locations)
    @property
    def history(self): return tuple(self._history)
    
    def is_consumed(self, packet:Packet):
        return packet.id in self._consumed_packets
    
    def is_registered(self, packet:Packet):
        return packet.id in self._packets
        
    def _create(self, data:Any, address):
        if type(data) == Packet:
            raise ValueError("Cannot create packet from another packet.")
        packet = Packet(_data=data, _id=self._num_packets)
        self._num_packets += 1
        self._packets[packet.id] = packet
        self._locations[packet] = address
        self._history.append(PacketCreation(packet, address))
        return packet
    
    def _create_empty(self, address):
        return self._create(NullPayload(), address)
        
    def _register_move(self, packet:Packet, dest:AddressableMixin, port_type:fbdev.port.PortType, port_name:str):
        if not self.is_registered(packet): raise ValueError("Packet not in registry.")
        if self.is_consumed(packet): raise ValueError("Packet is consumed.")
        current_address = self.locations[packet]
        if dest.address == current_address: raise ValueError("Packet is already at destination.")
        dest_address = dest.address
        moving_via = (port_type, port_name)
        self._history.append(PacketMovement(packet, current_address, dest_address, port_type, port_name))
        self._locations[packet] = dest_address
        
    async def _consume(self, packet:Packet):
        if not self.is_registered(packet): raise ValueError("Packet not in registry.")
        if self.is_consumed(packet): raise ValueError("Packet already consumed.")
        del self._locations[packet]
        self._consumed_packets.add(packet.id)
        data = packet._data # TODO this will be changed when we also have remote packets
        return data
    
    async def _peek(self, packet:Packet):
        data = packet._data # TODO this will be changed when we also have remote packets
        return data

# %% ../nbs/api/00_packet.ipynb 19
class PacketHandler:
    """
    A handler for packets for Nodes. The handler knows its own address, and verifies the packets against it.
    """
    def __init__(self, registry:PacketRegistry, parent_node:fbdev.node.Node):
        self._registry:PacketRegistry = registry
        self._parent_node:fbdev.node.Node = parent_node
        
    @property
    def registry(self): return self._registry
        
    def _verify_location(self, packet:Packet):
        if self._registry.locations[packet] != self._parent_node.address:
            raise ValueError(f"Packet location is {self.registry.locations[packet]}, but expected {self._parent_node.address}.")
        
    def is_consumed(self, packet:Packet):
        return self._registry.is_consumed(packet)
        
    def _create(self, data:Any):
        return self._registry._create(data, self._parent_node.address)
    
    def _create_empty(self):
        return self._registry._create_empty()
    
    def _register_move(self, packet:Packet, dest:AddressableMixin, port_type:fbdev.port.PortType, port_name:str):
        if dest.address != self._parent_node.address:
            self._verify_location(packet) # If the packet is being sent away, then verify that it is currently located at self._parent_node
        self._registry._register_move(packet, dest, port_type, port_name)
        
    async def _consume(self, packet:Packet):
        self._verify_location(packet)
        return await self._registry._consume(packet)
    
    async def peek(self, packet:Packet):
        self._verify_location(packet)
        return await self._registry._peek(packet)
