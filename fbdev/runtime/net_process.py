"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/02_runtime/02_net_process.ipynb.

# %% auto 0
__all__ = ['NetProcess']

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 4
import asyncio
from abc import ABC, abstractmethod
from types import MappingProxyType
from typing import Type, Tuple, Dict

import fbdev
from ..exceptions import NodeError, EdgeError
from ..comp.packet import Packet
from ..comp.port import PortType, PortSpec, PortSpecCollection, PortID, PortCollection
from ..comp.base_component import BaseComponent
from ..graph.graph_spec import GraphSpec, NodeSpec
from ..graph.packet_registry import TrackedPacket
from ..graph.net import Edge, Node, Net
from ..graph.graph_component import GraphComponentFactory
from .base_net_runtime import BaseNetRuntime

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 7
class NetProcess(BaseNetRuntime):
    def __init__(self, net:Net, stop_port:PortID=None):
        super().__init__()
        self._net:Net = net
        self._stop_port = stop_port
        self._stop_listener_task = None
        
        if self._stop_port is not None and self._stop_port not in self._net.ports:
            raise ValueError(f"Port {self._stop_port} does not exist in net.")

    @property
    def ports(self) -> PortCollection: return self._net.ports

    def start(self):
        """Note: this method cannot be run from within an event loop."""
        super().start()
        raise NotImplementedError("NetProcess does not support synchronous execution.")
    
    async def astart(self):
        await super().astart()
        
        if self._stop_port is not None:
            async def stop_listener():
                try:
                    await self._net.ports[self._stop_port].get()
                    if not self._stopped: await self.stop()
                except asyncio.CancelledError: pass
            self._stop_listener_task = asyncio.create_task(stop_listener())
            
        await self._net.start()
        self._started = True
    
    async def await_stop(self):
        # Tried doing this by creating an event self._stop_event.
        # For some reason this would cause all tasks to just hang forever.
        # So instead, we just wait for the net to stop.
        # Really perplexing...
        await self._net.task_manager.exec_coros(self._net.states.stopped.wait(True), print_all_exceptions=False)
    
    async def stop(self):
        await super().stop()
        if self._stop_listener_task is not None:
            self._stop_listener_task.cancel()
            try: await self._stop_listener_task
            except asyncio.CancelledError: pass
        await self._net.task_manager.exec_coros(self._net.stop(), print_all_exceptions=False)
        self._stopped = True
        
    async def await_message(self, name:str):
        await self._net.task_manager.exec_coros(self._net.await_message(name), print_all_exceptions=False)
