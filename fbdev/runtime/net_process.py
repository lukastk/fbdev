"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/02_runtime/02_net_process.ipynb.

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 4
from __future__ import annotations
import asyncio
from abc import ABC, abstractmethod
from types import MappingProxyType
from typing import Type, Tuple, Dict

import fbdev
from ..exceptions import NodeError, EdgeError
from ..comp.packet import Packet
from ..comp.port import PortType, PortSpec, PortSpecCollection, PortID, PortCollection
from ..comp.base_component import BaseComponent
from ..graph.graph_spec import GraphSpec, NodeSpec
from ..graph.packet_registry import TrackedPacket
from ..graph.net import Edge, Node, Net
from ..graph.graph_component import GraphComponentFactory
from .base_net_runtime import BaseNetRuntime

# %% auto 0
__all__ = ['NetProcess']

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 7
class NetProcess(BaseNetRuntime):
    def __init__(self, net:Net, stop_port:PortID=None):
        super().__init__()
        self._net:Net = net
        self._started = False
        self._stopped = False
        self._stop_port = stop_port
        self._stop_event = asyncio.Event()
        
        if self._stop_port is not None and self._stop_port not in self._net.ports:
            raise ValueError(f"Port {self._stop_port} does not exist in net.")

    @property
    def ports(self) -> PortCollection: return self._net.ports

    def execute(self):
        """Note: this method cannot be run from within an event loop."""
        raise NotImplementedError("NetProcess does not support synchronous execution.")
    
    async def aexecute(self):
        if self._started: raise RuntimeError("NetProcess has already been started.")
        if self._stopped: raise RuntimeError("NetProcess has been terminated.")
        
        if self._stop_port is not None:
            async def stop_packet_receiver():
                packet = await self._net.ports[self._stop_port].get()
                if not self._stopped:
                    await self.stop()
            asyncio.create_task(stop_packet_receiver())
        
        await self._net.start()
        self._started = True
    
    async def await_stop(self):
        await self._stop_event.wait()
    
    async def stop(self):
        if not self._started: raise RuntimeError("NetProcess has not yet been started.")
        if self._stopped: raise RuntimeError("NetProcess has already been terminated.")
        await self._net.terminate()
        self._stopped = True
        self._stop_event.set()
