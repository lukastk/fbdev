"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/02_runtime/00_base_net_runtime.ipynb.

# %% ../../nbs/api/02_runtime/00_base_net_runtime.ipynb 4
from __future__ import annotations
import asyncio
from abc import ABC, abstractmethod
from types import MappingProxyType
from typing import Type, Tuple, Dict

import fbdev
from ..exceptions import NodeError, EdgeError
from ..comp.packet import Packet
from ..comp.port import PortType, PortSpec, PortSpecCollection, PortID
from ..comp.base_component import BaseComponent
from ..graph.graph_spec import GraphSpec, NodeSpec
from ..graph.packet_registry import TrackedPacket
from ..graph.net import Edge, Node, Net
from ..graph.graph_component import GraphComponentFactory

# %% auto 0
__all__ = ['BaseNetRuntime']

# %% ../../nbs/api/02_runtime/00_base_net_runtime.ipynb 6
class BaseNetRuntime(ABC):
    @classmethod
    def from_graph(cls, graph:GraphSpec):
        component_type = GraphComponentFactory.create_component(graph)
        net_spec = NodeSpec(component_type)
        net = Net(net_spec)
        return cls(net)
    
    @classmethod
    def from_component(cls, component:Type[BaseComponent], prefix_ports_with_node_id=False):
        graph = GraphSpec(PortSpecCollection(), inherit_base_component_ports=False)
        graph.add_node(component)
        print(graph.ports)
        graph.add_and_connect_unconnected_child_ports(prefix_with_node_id=prefix_ports_with_node_id, exclude_port_types=[])
        return cls.from_graph(graph)
    
    @classmethod
    def execute_graph(cls, graph:GraphSpec, *args, config_vals={}, **kwargs):
        with cls.from_graph(graph) as netrun:
            return netrun.execute(*args, config_vals, **kwargs)
    
    @classmethod
    async def aexecute_graph(cls, graph:GraphSpec, *args, config_vals={}, **kwargs):
        async with cls.from_graph(graph) as netrun:
            return await netrun.aexecute(*args, config=config_vals, **kwargs)
    
    @abstractmethod
    def execute(self, *args, config={}, **kwargs): ...
    
    @abstractmethod
    async def aexecute(self, *args, config_vals={}, **kwargs): ...
    
    @abstractmethod
    async def stop(self): ...
    
    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.stop()
        
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        asyncio.run(self.stop())
