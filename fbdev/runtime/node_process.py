"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/02_runtime/02_net_process.ipynb.

# %% auto 0
__all__ = ['NodeProcess']

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 4
import asyncio

import fbdev
from ..comp.port import PortType, PortSpec, PortSpecCollection, PortID, PortCollection
from ..graph.net import BaseNode
from . import BaseRuntime

# %% ../../nbs/api/02_runtime/02_net_process.ipynb 7
class NodeProcess(BaseRuntime):
    def __init__(self, node:BaseNode, stop_port:PortID=None):
        super().__init__()
        self._node:BaseNode = node
        self._stop_port = stop_port
        self._stop_listener_task = None
        
        if self._stop_port is not None and self._stop_port not in self._node.ports:
            raise ValueError(f"Port {self._stop_port} does not exist in node.")

    @property
    def ports(self) -> PortCollection: return self._node.ports

    def start(self):
        """Note: this method cannot be run from within an event loop."""
        super().start()
        raise NotImplementedError(f"{self.__class__.__name__} does not support synchronous execution.")
    
    async def astart(self):
        await super().astart()
        
        if self._stop_port is not None:
            async def stop_listener():
                try:
                    await self._node.ports[self._stop_port].get()
                    if not self._stopped: await self.stop()
                except asyncio.CancelledError: pass
            self._stop_listener_task = asyncio.create_task(stop_listener())
            
        await self._node.task_manager.exec_coros(self._node.start())
        self._started = True
    
    async def await_stop(self):
        # Tried doing this by creating an event self._stop_event.
        # For some reason this would cause all tasks to just hang forever.
        # So instead, we just wait for the node to stop.
        # Really perplexing...
        await self._node.task_manager.exec_coros(self._node.states.stopped.wait(True), print_all_exceptions=False)
    
    async def stop(self):
        await super().stop()
        if self._stop_listener_task is not None:
            self._stop_listener_task.cancel()
            try: await self._stop_listener_task
            except asyncio.CancelledError: pass
        await self._node.task_manager.exec_coros(self._node.stop(), print_all_exceptions=False)
        self._stopped = True
        
    async def await_message(self, name:str):
        await self._node.task_manager.exec_coros(self._node.await_message(name), print_all_exceptions=False)
