"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/05_execute.ipynb.

# %% auto 0
__all__ = ['NetExecutor', 'BatchExecutor']

# %% ../nbs/api/05_execute.ipynb 4
import asyncio
from collections import deque
from types import MappingProxyType
from typing import Type, Optional, Union, Any, Tuple, Dict

import fbdev
from .packet import Packet
from .port import PortType, PortSpec, ConfigPortSpec, PortTypeSpec, PortSpecCollection, BasePort, InputPort, ConfigPort, OutputPort, PortCollection
from .component import BaseComponent, ComponentFactory, PortSpec, BasePort, InputPort, OutputPort, PortCollection, PortType
from .graph import EdgeSpec, NodeSpec, Graph, ReadonlyGraph
from .exceptions import ComponentError, NodeError, LostPacketError
from .node import Node, CompositeComponentFactory

# %% ../nbs/api/05_execute.ipynb 7
class NetExecutor:
    #TODO not clear yet what abstractions this will have, so everything is in `BatchExecutor` for now.
    pass

# %% ../nbs/api/05_execute.ipynb 9
class BatchExecutor(NetExecutor):
    """Executes a net like a batch process (input fed in the beginning, and no input during the execution, and output is returned at the end)."""
    def __init__(self, net_spec:NodeSpec):
        super().__init__()
        self._net_spec:NodeSpec = net_spec
        self._net:Node = None
    
    @classmethod
    def from_graph(cls, graph:Graph, parent_process=None):
        component_type = CompositeComponentFactory.get_component(graph)
        net_spec = NodeSpec(component_type)
        return cls(net_spec)
    
    @classmethod
    def execute_graph(cls, graph:Graph, *args, config={}, **kwargs):
        ex = cls.from_graph(graph)
        return ex.execute(*args, config, destroy_net=True, **kwargs)
    
    @classmethod
    async def async_execute_graph(cls, graph:Graph, *args, config={}, **kwargs):
        ex = cls.from_graph(graph)
        return await ex.async_execute(*args, config=config, **kwargs)
    
    def _execute_setup(self, *args, config={}, destroy_net=True, **kwargs):
        if self._net is None:
            self._net = net = Node(node_spec=self._net_spec, parent_comp_process=None)
            net.initialise()
        
        if net.states.running.get(): raise RuntimeError("Net is already running.")
        if not net.states.initialised.get(): raise RuntimeError("Net is not initialised.")
        
        # Fill in input args
        input = {**kwargs}
        for port_name, val in zip(net.port_specs.input.keys(), args):
            if port_name in input:
                raise ValueError(f"Multiple values provided for '{port_name}'.")
            input[port_name] = val
        missing_input_args = set(net.port_specs.input.keys()) - set(input.keys())
        if len(missing_input_args) > 0:
            raise ValueError(f"Missing values for ports {missing_input_args}.")
        
        # Check for unexpected input args
        extra_input_args = set(input.keys()) - set(net.port_specs.input.keys())
        if len(extra_input_args) > 0:
            raise ValueError(f"Unexpected values for inputs {extra_input_args}.")
        
        # Check for unexpected config args
        extra_config_args = set(config.keys()) - set(net.port_specs.config.keys())
        if len(extra_config_args) > 0:
            raise ValueError(f"Unexpected values for configs {extra_config_args}.")
        
        async def input_sender():
            for port_name, val in input.items():
                await net.send_input(PortType.INPUT, port_name, Packet(val))
                
        output = {}
        async def output_receiver():
            for port_name in net.port_specs.output.keys():
                packet = await net.receive_output(PortType.OUTPUT, port_name)
                packet_payload = await packet.consume()
                output[port_name] = packet_payload
        
        async def main():
            net.run()
            await net._run_with_exception_monitoring(input_sender(), output_receiver())
            await net._run_with_exception_monitoring(net.async_stop())
            if destroy_net:
                await net._run_with_exception_monitoring(net.destroy())
            
        return main(), output

    def execute(self, *args, config={}, destroy_net=True, **kwargs):
        """Note: this method cannot be run from within an event loop."""
        exec_coro, output = self._execute_setup(*args, config=config, destroy_net=destroy_net, **kwargs)
        asyncio.run(exec_coro)
        return output
    
    async def async_execute(self, *args, config={}, destroy_net=True, **kwargs):
        exec_coro, output = self._execute_setup(*args, config=config, destroy_net=destroy_net, **kwargs)
        await exec_coro
        return output
    
    async def destroy(self):
        if self._net is not None:
            await self._net.destroy()
            self._net = None
    
    def __del__(self):
        if self._net is not None:
            #TODO log a warning or handle the case where close() was not called
            pass
