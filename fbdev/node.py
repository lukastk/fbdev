# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/04_node.ipynb.

# %% auto 0
__all__ = ['Edge', 'Node', 'CompositeComponentFactory']

# %% ../nbs/api/04_node.ipynb 4
import asyncio
from collections import deque
from types import MappingProxyType
from typing import Type, Optional, Union, Any, Tuple, Dict, Coroutine, List

import fbdev
from .utils import StateHandler, StateView, StateCollection, EventHandler, EventCollection, AttrContainer, await_multiple_events, await_any_event, TaskManager, is_in_event_loop
from .packet import Packet
from .port import PortType, PortSpec, ConfigPortSpec, PortTypeSpec, PortSpecCollection, BasePort, InputPort, ConfigPort, OutputPort, PortCollection
from .component import BaseComponent, ComponentFactory, PortSpec, BasePort, InputPort, OutputPort, PortCollection, PortType
from .graph import EdgeSpec, NodeSpec, Graph, ReadonlyGraph
from .exceptions import ComponentError, NodeError, LostPacketError

# %% ../nbs/api/04_node.ipynb 7
class Edge:
    def __init__(self,
                 edge_spec:EdgeSpec,
                 parent_process):
        self._parent_process = parent_process
        self._edge_spec = edge_spec
                
        self._states = StateCollection()
        self._states._add_state(StateHandler("enabled", True), readonly=False)
        self._states._add_state(StateHandler("empty", True), readonly=True)
        self._states._add_state(StateHandler("full", False), readonly=True)
        
        self._events = EventCollection()
        self._events._add_event(EventHandler("has_changed"))
        
        self._maxsize = edge_spec.maxsize
        self._packets = deque(maxlen=edge_spec.maxsize)

    @property
    def parent_process(self): return self._parent_process
    @property
    def edge_spec(self): return self._edge_spec    
    @property
    def states(self): return self._states
    @property
    def events(self): return self._events
    
    @property
    def id(self): return self._edge_spec.id     
    @property
    def tail_connection(self):
        if self.id in self.parent_process.graph.edge_to_tail_connections:
            target_id = self.parent_process.graph.edge_to_tail_connections[self.id]
            if target_id != 0:
                return self.parent_process.nodes[target_id]
            else:
                return self.parent_process
        else:
            return None
    @property
    def head_connection(self):
        if self.id in self.parent_process.graph.edge_to_head_connections:
            target_id = self.parent_process.graph.edge_to_head_connections[self.id]
            if target_id != 0:
                return self.parent_process.nodes[target_id]
            else:
                return self.parent_process
        else:
            return None

    @property
    def maxsize(self): return self.edge_spec.maxsize
        
    def num_packets(self): return len(self._packets)
        
    def _update_status_events(self):        
        if len(self._packets) > 0: self.states._empty.set(False)
        else: self.states._empty.set(True)
        if len(self._packets) == self.maxsize and self.maxsize is not None: self.states._full.set(True)
        else: self.states._full.set(False)
    
    def _load(self, packet:Packet):
        if self.states.full.get(): raise RuntimeError("Port is full.")
        self._packets.append(packet)
        self._update_status_events()
        self.events.has_changed._trigger()
        
    def _unload(self):
        if self.states.empty.get(): raise RuntimeError("Port is empty.")
        packet = self._packets.popleft()
        self._update_status_events()
        self.events.has_changed._trigger()
        return packet
    
    def _load_left(self, packet: Packet):
        if self.states.full.get(): raise RuntimeError("Port is full.")
        self._packets.appendleft(packet)
        self._update_status_events()
        self.events.has_changed._trigger()
    
    def _unload_right(self):
        if self.states.empty.get(): raise RuntimeError("Port is empty.")
        packet = self._packets.pop()
        self._update_status_events()
        self.events.has_changed._trigger()
        return packet
        
    def _unload_all(self):
        if self.states.empty.get(): raise RuntimeError("Port is empty.")
        packets = list(self._packets)
        self._packets.clear()
        self._update_status_events()
        self.events.has_changed._trigger()
        return packets

# %% ../nbs/api/04_node.ipynb 9
class Node:
    def __init__(self, node_spec:NodeSpec, parent_comp_process):
        if node_spec.component_type.is_factory:
            raise ValueError("Node cannot have a component type that is a ComponentFactory.")
        
        self._parent_comp_process = parent_comp_process
        self._node_spec = node_spec
        self._component_process = None
        self._task_manager = TaskManager(self)
        
        self._states = StateCollection()
        self._states._add_state(StateHandler("initialised", False), readonly=True)
        self._states._add_state(StateHandler("configured", False), readonly=True)
        self._states._add_state(StateHandler("running", False), readonly=True)
        self._states._add_state(StateHandler("stopping", False), readonly=True)
        self._states._add_state(StateHandler("component_executing", False), readonly=True)

        self._events = EventCollection()
        self._events._add_event(EventHandler("stopped_running"))

        self._edge_buses:Dict[Tuple[PortType, str], asyncio.Task] = {}
        self._edge_bus_resting:Dict[Tuple[PortType, str], asyncio.Event] = {}
        self._config_port_handlers:Dict[str, asyncio.Task] = {}
        
    @property
    def parent_comp_process(self): return self._parent_comp_process
    @property
    def parent_node(self): return self._parent_comp_process._parent_node
    @property
    def is_top_level(self): return self._parent_comp_process is None
    @property
    def node_spec(self): return self._node_spec
    @property
    def id(self):
        if self.is_top_level: return 'net'
        else: return self.node_spec.id
    @property
    def component_type(self): return self.node_spec.component_type
    @property
    def component_process(self): return self._component_process
    @property
    def port_specs(self): return self.node_spec.component_type.port_specs
    @property
    def ports(self): return self.component_process.ports
    @property
    def states(self): return self._states
    @property
    def events(self): return self._events
    
    @property
    def address(self):
        if issubclass(self.component_type, CompositeComponentFactory):
            node_type_name = 'Net' if self.is_top_level else 'SubNet'
        else:
            node_type_name = 'Node'
        if not self.is_top_level:
            prefix = self.parent_node.address + '.'
        else:
            prefix = ''
    
        return f"{prefix}{node_type_name}({self.id})"
    
    @property
    def incoming_edges(self):
        input_edges = {}
        if self.parent_comp_process is None: return {}
        for port_spec in self.port_specs.iter_ports():
            key = (self.id, port_spec.port_type, port_spec.name)
            if key in self.parent_comp_process.graph.head_connections:
                edge_id = self.parent_comp_process.graph.head_connections[key]
                input_edges[(port_spec.port_type, port_spec.name)] = self.parent_comp_process.edges[edge_id]
        return input_edges
    @property
    def outgoing_edges(self):
        output_edges = {}
        if self.parent_comp_process is None: return {}
        for port_spec in self.port_specs.iter_ports():
            key = (self.id, port_spec.port_type, port_spec.name)
            if key in self.parent_comp_process.graph.tail_connections:
                edge_id = self.parent_comp_process.graph.tail_connections[key]
                output_edges[(port_spec.port_type, port_spec.name)] = self.parent_comp_process.edges[edge_id]
        return output_edges
    @property
    def adjacent_edges(self):
        return {**self.incoming_edges, **self.outgoing_edges}
    
    def _handle_component_process_exception(self, task:asyncio.Task, exception:Exception, source_trace:Tuple[Union[BaseComponent], ...]):
        try:
            raise ComponentError() from exception
        except ComponentError as e:
            if not self.states.stopping.get(): self.stop()
            self._task_manager.submit_exception(task, e, source_trace)
    
    def initialise(self):
        self._component_process = self.component_type()
        self._component_process._parent_node = self
        self._component_process._task_manager.subscribe(self._handle_component_process_exception)
        self.states._initialised.set(True)
        self.states._configured.set(self.component_process.check_configured())
        
    def reset(self):
        self._component_process = None
        self.states._initialised.set(False)
        self.states._configured.set(False)
                
    async def _handle_in_edge_port_connection(self, edge:Edge, port:BasePort, is_resting:asyncio.Event):
        try:
            edge_non_empty = edge.states.empty.get_state_event(False)
            while True:
                await await_multiple_events(port._requesting_packet, edge_non_empty)
                is_resting.clear()
                port._load_packet(edge._unload())
                port._received_packet.set()
                is_resting.set()
                await asyncio.sleep(0)
        except asyncio.CancelledError: pass
            
    async def _handle_out_edge_port_connection(self, edge:Edge, port:BasePort, is_resting:asyncio.Event):
        try:
            edge_non_full = edge.states.full.get_state_event(False)
            while True:
                await await_multiple_events(port._ready_to_unload, edge_non_full)
                is_resting.clear()
                edge._load(port._unload_packet())
                port._package_sent.set()
                is_resting.set()
                await asyncio.sleep(0)
        except asyncio.CancelledError: pass
        
    async def _handle_component_config(self, config_port):
        """Continually awaits receiving packets at a config port, and updates the component process's config."""
        try:
            while True:
                packet = await config_port._receive()
                await self.states.component_executing.wait(False) # Doing the awaits in this order guarantees that a config wont be updated whilst the component is executing (though it can be received during it).
                await self.component_process.set_config(config_port.name, packet)
                packet = None
                self.states._configured.set(self.component_process.check_configured())
                await asyncio.sleep(0)
        except asyncio.CancelledError: pass
        finally:
            if packet is not None:
                raise LostPacketError(packet, f"Packet lost in {self.__class__.__name__}._handle_component_config. Id: {self.address}")
        
    def _start_edge_bus(self, port_type:PortType, port_name:str, edge:Edge):
        port = self.component_process.ports[port_type][port_name]
        is_resting = asyncio.Event()
        if port_type.is_input_port:
            edge_bus = self._task_manager.create_task(self._handle_in_edge_port_connection(edge, port, is_resting))
        else:
            edge_bus = self._task_manager.create_task(self._handle_out_edge_port_connection(edge, port, is_resting))
        self._edge_buses[(port_type, port_name)] = edge_bus
        self._edge_bus_resting[(port_type, port_name)] = is_resting
        
    async def _stop_edge_bus(self, port_type:PortType, port_name:str):
        await self._task_manager.cancel_wait(self._edge_buses[(port_type, port_name)])
        del self._edge_buses[(port_type, port_name)]
        del self._edge_bus_resting[(port_type, port_name)]
        
    def _start_config_handler(self, port_name:str):
        port = self.component_process.ports[PortType.CONFIG][port_name]
        config_task = self._task_manager.create_task(self._handle_component_config(port))
        self._config_port_handlers[port_name] = config_task
        
    async def _stop_config_handler(self, port_name:str):
        await self._task_manager.cancel_wait(self._config_port_handlers[port_name])
        
    async def send_input(self, port_type:PortType, port_name:str, packet:Packet):
        if not port_type.is_input_port: raise ValueError(f"Port type {port_type} is not an input port.")
        port = self.component_process.ports[port_type][port_name]
        if (port_type, port_name) in self._edge_buses:
            await await_multiple_events(port._requesting_packet, self._edge_bus_resting[(port_type, port_name)])
        else:
            await port._requesting_packet.wait()
        port._load_packet(packet)
        port._received_packet.set()
        
    async def receive_output(self, port_type:PortType, port_name:str) -> Packet:
        if port_type.is_input_port: raise ValueError(f"Port type {port_type} is not an output port.")
        port = self.component_process.ports[port_type][port_name]
        if (port_type, port_name) in self._edge_buses:
            await await_multiple_events(port._ready_to_unload, self._edge_bus_resting[(port_type, port_name)])
        else:
            await port._ready_to_unload.wait()
        packet = port._unload_packet()
        port._package_sent.set()
        return packet
                
    def run(self):
        self._run_task = self._task_manager.create_task(self._run())
        
    async def _run(self):
        if not self.states.initialised.get(): raise RuntimeError("Node is not initialised.")
        if self.states.running.get(): raise RuntimeError("Node is already running.")
        self.states._running.set(True)
        self.states._stopping.set(False)
    
        # Run component
        try:
            # Start edge buses
            for (port_type, port_name), edge in self.adjacent_edges.items():
                self._start_edge_bus(port_type, port_name, edge)
            
            # Start config handlers
            for port_name in self.port_specs[PortType.CONFIG]:
                self._start_config_handler(port_name)
                
            await self.component_process.start_background_tasks()
            while True:
                await self.states.configured.wait(True)
                if self.component_process.is_passive:
                    await asyncio.get_running_loop().create_future() # Wait forever
                else:
                    self.states._component_executing.set(True)
                    await self.component_process.execute()
                    self.states._component_executing.set(False)
                    await asyncio.sleep(0)
        except asyncio.CancelledError:
            pass
        finally:
            await self.component_process.stop_background_tasks()
            # Stop edge buses
            for port_type, port_name in list(self._edge_buses.keys()):
                await self._stop_edge_bus(port_type, port_name)
            
            # Stop config handlers
            for port_name in list(self.port_specs[PortType.CONFIG].keys()):
                await self._stop_config_handler[port_name]
                
            self.states._running.set(False)
            self.states._stopping.set(False)
             
    async def _run_with_exception_monitoring(self, *coros: List[Coroutine]):
        """Run a coroutine and monitor for exceptions in the coroutine, as well as
        any exceptions that occurs in the task manager. Therefore, for it to work
        as expected, the coroutine must be starting tasks using self._task_manager.create_task().
        """
        async def all_coros():
            await asyncio.gather(*[asyncio.create_task(coro) for coro in coros])
        task = asyncio.create_task(all_coros())
        monitor_task = asyncio.create_task(self._task_manager.wait_for_exceptions())
        await asyncio.wait([task, monitor_task], return_when=asyncio.FIRST_COMPLETED)
        exceptions = self._task_manager.get_exceptions()
        if task.done():
            try: await task
            except Exception as e: exceptions.append((task, e, ()))
        if not monitor_task.done():
            monitor_task.cancel()
        for task, e, source_trace in exceptions:
            raise e
             
    def stop(self):
        if not self.states.running.get(): raise RuntimeError("Node is not running.")
        if self.states.stopping.get(): raise RuntimeError("Node is already stopping.")
        self.states._stopping.set(True)
        self._task_manager.cancel(self._run_task)
             
    async def async_stop(self):
        self.stop()
        try:
            await self.states.running.wait(False)
        except asyncio.CancelledError:
            print(asyncio.current_task())
            raise
        
    async def destroy(self):
        if self.states.running.get(): await self.async_stop()
        await self.component_process.destroy()
        await self._task_manager.destroy()
        self.reset()

# %% ../nbs/api/04_node.ipynb 11
class CompositeComponentFactory(ComponentFactory):
    is_passive = True
    
    def __init__(self, graph:Graph):
        super().__init__()
        
        self._graph = graph
        self._read_only_graph = ReadonlyGraph(graph)
        self._edges = {}
        self._nodes = {}
        
        self._in_buses = []
        self._out_buses = []
        self._config_buses = []
        
        # Add edges
        for edge_spec in self.graph.edges.values():
            self._edges[edge_spec.id] = Edge(edge_spec, self)
        # Add nodes
        for node_spec in self.graph.nodes.values():
            node =  Node(node_spec, self)
            self._nodes[node_spec.id] = node
            node._task_manager.subscribe(self._handle_child_node_exception)
            
        # Initialise nodes
        # TODO allow for more custom initialisation procedure
        for node in self.nodes.values():
            node.initialise()
    
    @property
    def graph(self): return self._read_only_graph
    @property
    def edges(self): return MappingProxyType(self._edges)
    @property
    def nodes(self): return MappingProxyType(self._nodes)
    
    def _handle_child_node_exception(self, task:asyncio.Task, exception:Exception, source_trace:Tuple[Node, ...]):
        try:
            raise NodeError() from exception
        except NodeError as e:
            self._task_manager.submit_exception(task, e, source_trace)
    
    @classmethod
    def get_component(cls, graph):
        port_specs = graph.port_specs
        return cls._create_component_class(class_attrs={'port_specs' : port_specs}, init_args=[graph])
    
    async def _handle_graph_in_port(self, graph_port:InputPort, edge:Edge):
        edge_non_full = edge.states.full.get_state_event(False)
        packet = None
        try:
            while True:
                    packet = await graph_port.receive() # TODO change the packet parent registry
                    await edge_non_full.wait()
                    edge._load(packet)
                    packet = None
                    await asyncio.sleep(0)
        except asyncio.CancelledError: pass
        finally:
            if packet is not None:
                if edge_non_full.is_set():
                    edge._load(packet) #TODO TBC on whether it is a good idea to do a last ditch effort to load the packet
                else:
                    raise LostPacketError(packet, f"Packet lost in {self.__class__.__name__}._handle_graph_in_port. Id: {self._parent_node.address}")
            
    async def _handle_graph_out_port(self, graph_port:OutputPort, edge:Edge):
        edge_non_empty = edge.states.empty.get_state_event(False)
        packet = None
        try:
            while True:
                await edge_non_empty.wait()
                packet = edge._unload()
                await graph_port.put(packet)
                packet = None
                await asyncio.sleep(0)
        except asyncio.CancelledError: pass
        finally:
            if packet is not None:
                raise LostPacketError(packet, f"Packet lost in {self.__class__.__name__}._handle_graph_out_port. Id: {self._parent_node.address}")
        
    async def _forward_config_into_graph(self, edge:Edge, packet:Packet):
        try:
            await edge.states.full.get_state_event(False)
        except asyncio.CancelledError: pass
        finally:
            if not edge.states.full.get():
                edge._load(packet) #TODO TBC on whether it is a good idea to do a last ditch effort to load the packet
            else:
                raise LostPacketError(packet, f"Packet lost in {self.__class__.__name__}._forward_config_into_graph. Id: {self._parent_node.address}")
        
    def set_config(self, name:str, packet:Packet):
        """Overloads BaseComponent.set_config to forward the config to child nodes, where such edges have been defined."""
        if (PortType.CONFIG, name) in self.graph.graph_tail_connections:
            edge_id = self.graph.graph_tail_connections[(PortType.CONFIG, name)]
            task = self._task_manager.create_task(self._forward_config_into_graph(self.edges[edge_id], packet))
            self._config_buses.append(task)
        else:
            super().set_config(name, packet)
    
    async def execute(self):
        await super().execute()
    
    async def start_background_tasks(self):
        # Don't catch CancelledError here, as it should never be cancelled, and if it is the exception should be raised.
        for (port_type, port_name), edge_id in self.graph.graph_tail_connections.items():
            if port_type == PortType.CONFIG:
                continue 
            task = self._task_manager.create_task(self._handle_graph_in_port(self.ports[port_type][port_name], self.edges[edge_id]))
            self._in_buses.append(task)
            
        for (port_type, port_name), edge_id in self.graph.graph_head_connections.items():
            task = self._task_manager.create_task(self._handle_graph_out_port(self.ports[port_type][port_name], self.edges[edge_id]))
            self._out_buses.append(task)
        
        for node in self.nodes.values():
            node.run()
            
    async def stop_background_tasks(self):
        # Don't catch CancelledError here, as it should never be cancelled, and if it is the exception should be raised.
        for task in self._in_buses+self._out_buses+self._config_buses:
            await self._task_manager.cancel_wait(task)
        self._in_buses.clear()
        self._out_buses.clear()
        self._config_buses.clear()
        for node in self.nodes.values():
            if node.states.running.get():
                await node.async_stop()
    
    async def destroy(self):
        await super().destroy()
        for node in self.nodes.values():
            await node.destroy()

