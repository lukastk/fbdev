"""TODO fill in description"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb.

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 4
from __future__ import annotations
from IPython.display import Markdown
from typing import List

import fbdev
from ...comp.port import PortType, PortSpec, PortSpecCollection
from ...comp import BaseComponent
from ..graph_spec import GraphSpec, NodePortSpec, NodeSpec

# %% auto 0
__all__ = ['graph_to_mermaid']

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 7
def __is_port_connected(port:NodePortSpec) -> bool:
    # This is really just used in `fbdev.graph.graph_spec_to_mermaid.graph_to_mermaid`
    externally_connected = (port._port_type, port.name) in port._parent_node._edge_connections
    if type(port._parent_node) == NodeSpec and port._parent_node.contains_graph:
        subgraph = port._parent_node.subgraph
        internally_connected = (port._port_type, port.name) in subgraph._edge_connections
    else: internally_connected = False
    return externally_connected or internally_connected

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 8
__port_type_to_node_shape = {
    PortType.INPUT: '[%s]',
    PortType.CONFIG: '[(%s)]',
    PortType.SIGNAL: '>%s]',
    PortType.OUTPUT: '[%s]',
    PortType.MESSAGE: '[[%s]]',
}

def __get_port_address(address_prefix:str, port:NodePortSpec):
    return f"{address_prefix}{port._parent_id}:{port.id_str}"
def __get_port_label(port:NodePortSpec):
    return __port_type_to_node_shape[port.port_type] % port.name
def __add_to_mm_class(mm_class, mm_id, mm_class_assignments):
    if mm_class not in mm_class_assignments:
        mm_class_assignments[mm_class] = []
    mm_class_assignments[mm_class].append(mm_id)

def __graph_to_mermaid_subgraph_structs(address_prefix:str,
                                        graph:GraphSpec,
                                        mm_edges,
                                        mm_class_assignments,
                                        hide_unconnected_ports:bool,
                                        hide_port_types:List[PortType]):
    def get_mermaid_struct():
        return {
            'mm_address' : None,
            'mm_label' : None,
            'mm_nodes' : [],
            'mm_node_labels' : [],
            'mm_subgraphs' : [],
        }
        
    def get_mm_edge(edge):
        tail_address = __get_port_address(address_prefix, edge.tail_port)
        head_address = __get_port_address(address_prefix, edge.head_port)
        arrow = '-.->' if edge.tail_is_graph or edge.head_is_graph else '-->'
        if edge.is_maxsize_finite: arrow = f"{arrow}|{edge.maxsize}|"
        return tail_address, arrow, head_address

    mm_subgraphs = []

    # Turn graph child nodes into mermaid subgraphs
    for node_spec in graph.nodes.values():
        mm_node_spec = get_mermaid_struct()
        mm_node_spec['mm_address'] = f"{address_prefix}{node_spec.id}"
        mm_node_spec['mm_label'] = node_spec.rich_id
        # Ports
        for port in node_spec.ports.iter_ports():
            if hide_unconnected_ports and not __is_port_connected(port): continue
            if not __is_port_connected(port) and port.port_type in hide_port_types: continue
            port_address = __get_port_address(address_prefix, port)
            __add_to_mm_class(port.port_type.label, port_address, mm_class_assignments)
            mm_node_spec['mm_nodes'].append(port_address)
            mm_node_spec['mm_node_labels'].append(__get_port_label(port))
        # Edges
        for edge in node_spec.edge_connections.values():
            if edge.tail is not None and edge.head is not None:
                mm_edges.add(get_mm_edge(edge))
        # Recursively deal with subgraphs
        if node_spec.contains_graph:
            # Add child nodes
            mm_node_spec_children_container = get_mermaid_struct()
            mm_node_spec_children_container['mm_address'] = f"{address_prefix}{node_spec.id}__PROP__children"
            __add_to_mm_class('subgraph_zone', mm_node_spec_children_container['mm_address'], mm_class_assignments)
            mm_node_spec_children_container['mm_label'] = " "
            mm_node_spec_children_container['mm_subgraphs'] = __graph_to_mermaid_subgraph_structs(
                f"{mm_node_spec['mm_address']}->", node_spec.subgraph, mm_edges, mm_class_assignments,
                hide_unconnected_ports, hide_port_types
            )
            mm_node_spec['mm_subgraphs'].append(mm_node_spec_children_container)
            
        mm_subgraphs.append(mm_node_spec)
        
    # Graph edge connections
    for edge_id in graph._edge_connections.values():
        edge = graph.edges[edge_id]
        if edge.tail is not None and edge.head is not None:
            mm_edges.add(get_mm_edge(edge))
        
    return mm_subgraphs

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 10
__invalid_mm_substrings = {
    '->' : '__D__',
    ':' : '__C__',
}

def __fmt(txt):
    for s in __invalid_mm_substrings:
        txt = txt.replace(s, __invalid_mm_substrings[s])
    return txt

def __convert_mm_structs_to_mermaid(merm_lines, mm_subgraph_structs, tab_level):
    def add_line(add_tabs, l="", format=True):
        if format: l = __fmt(l)
        merm_lines.append((tab_level+add_tabs) * '    ' + l)
        
    for mm_sgs in mm_subgraph_structs:
        add_line(0, f"subgraph {mm_sgs['mm_address']}[\"{mm_sgs['mm_label']}\"]")
        for mm_node, mm_node_label in zip(mm_sgs['mm_nodes'], mm_sgs['mm_node_labels']):
            add_line(1, f"{mm_node}{mm_node_label}")
        __convert_mm_structs_to_mermaid(merm_lines, mm_sgs['mm_subgraphs'], tab_level+1)
        add_line(0, 'end')

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 11
__mermaid_class_defs = {
    'input' : 'fill:#13543e',
    'output' : 'fill:#0d1b59',
    'subgraph_zone' : 'fill:#000',
}

# %% ../../../nbs/api/01_graph/utils/00_graph_spec_to_mermaid.ipynb 13
def graph_to_mermaid(graph:GraphSpec,
                     orientation='',
                     hide_unconnected_ports=False,
                     hide_port_types:List[PortType]=[]) -> str:
    """
    TB - Top to bottom
    TD - Top-down/ same as top to bottom
    BT - Bottom to top
    RL - Right to left
    LR - Left to right
    """
    mm_class_assignments = {}
    mm_edges = set()
    
    mm_subgraph_structs = __graph_to_mermaid_subgraph_structs("", graph, mm_edges, mm_class_assignments,
                                                              hide_unconnected_ports, hide_port_types)
    merm_lines = [f'flowchart {orientation}']
    __convert_mm_structs_to_mermaid(merm_lines, mm_subgraph_structs, 1)
    
    # Add graph ports
    for port in graph.ports.iter_ports():
        port_address = __get_port_address('', port)
        __add_to_mm_class(port.port_type.label, port_address, mm_class_assignments)
        merm_lines.append(__fmt(f"    {port_address}{__get_port_label(port)}"))

    # Add edges
    for mm_edge in mm_edges:
        tail_address, arrow, head_address = mm_edge
        tail_address = __fmt(tail_address.replace(f"->{GraphSpec.GRAPH_ID}", '')) # A hack...
        head_address = __fmt(head_address.replace(f"->{GraphSpec.GRAPH_ID}", ''))
        merm_lines.append(f"    {tail_address} {arrow} {head_address}")
        
    # Add class definitions
    for class_name, class_def in __mermaid_class_defs.items():
        merm_lines.append(f"    classDef {__fmt(class_name)} {class_def};")
        
    # Add classes
    for class_name, class_instances in mm_class_assignments.items():
        class_instances = ",".join(class_instances)
        merm_lines.append(__fmt(f"    class {class_instances} {class_name};"))
        
    return "\n".join(merm_lines)
