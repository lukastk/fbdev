# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/ports.ipynb.

# %% auto 0
__all__ = ['BasePort', 'BaseInputPort', 'SingleInputPort', 'DequeInputPort', 'BaseOutputPort', 'SingleOutputPort',
           'DequeOutputPort']

# %% ../nbs/api/ports.ipynb 4
import asyncio
from abc import ABC, abstractmethod
from typing import Type, Callable, Any
import inspect
from collections import deque

import fbdev
from . import Packet
from .packet_container import PacketContainer, SinglePacketContainer, DequePacketContainer

# %% ../nbs/api/ports.ipynb 5
__all__ = [
    'BasePort',
    'BaseInputPort', 'SingleInputPort', 'DequeInputPort',
    'BaseOutputPort', 'SingleOutputPort', 'DequeOutputPort'
]

# %% ../nbs/api/ports.ipynb 7
class BasePort:
    def __init__(self,
                 name:str,
                 dtype:type,
                 data_validator:Callable[[Any], bool]):
        self.name = name
        self.idx = None
        self._component_process = None
        self.dtype = dtype
        self.data_validator = data_validator
        
    def attach(self, component_process, port_index:int):
        if self._component_process is not None:
            #TODO proper exception in BasePort.attach
            raise Exception("Port is already attached.")
        self._component_process = component_process
        self.idx = port_index
        
    def _check_packet_data_dtype(self,
                                 packet_data):
        if self.dtype is not None:
            if type(packet_data) != self.dtype:
                #TODO logging in BasePort._check_packet_data_dtype
                #TODO proper exceptions in BasePort._check_packet_data_dtype
                #TODO unit test BasePort._check_packet_data_dtype
                raise Exception("Wrong dtype.")
        
    def _check_packet_dtype(self,
                            packet: Type[Packet]):
        if self.dtype is not None:
            if packet.dtype != self.dtype:
                #TODO logging in BasePort._check_packet_dtype
                #TODO proper exceptions in BasePort._check_packet_dtype
                #TODO unit test BasePort._check_packet_dtype
                raise Exception("Wrong dtype.")
            
    def _validate_packet_data(self,
                       packet_data):
        if self.data_validator is not None:
            if not self.data_validator(packet_data):
                #TODO logging in BasePort._validate_packet_data
                #TODO proper exceptions in BasePort._validate_packet_data
                #TODO unit test BasePort._validate_packet_data
                raise Exception("Data is invalid.")

# %% ../nbs/api/ports.ipynb 10
class BaseInputPort(BasePort, PacketContainer):
    def __init__(self,
                 name:str,
                 dtype: type=None,
                 data_validator: Callable[[Any], bool]=None):
        PacketContainer.__init__(self)
        BasePort.__init__(self, name, dtype, data_validator)
        
    def unload(self):
        raise NotImplementedError("`unload` is disabled for input ports.")
    
    @abstractmethod
    async def receive(self):
        raise NotImplementedError()

# %% ../nbs/api/ports.ipynb 12
class SingleInputPort(BaseInputPort, SinglePacketContainer):
    def __init__(self,
                 name:str,
                 dtype:type=None,
                 data_validator:Callable[[Any], bool]=None):
        BaseInputPort.__init__(self, name, dtype, data_validator)
        SinglePacketContainer.__init__(self)

    def load(self, packet):
        self._check_packet_dtype(packet)
        super().load(packet)
        
    async def receive(self):
        await self.empty.wait(False)
        packet = SinglePacketContainer.unload(self)
        packet_data = packet.get_data()
        if inspect.isawaitable(packet_data): packet_data = await packet_data
        self._validate_packet_data(packet_data)
        self._packet = None
        self._set_empty_state()
        return packet_data

# %% ../nbs/api/ports.ipynb 15
class DequeInputPort(BaseInputPort, DequePacketContainer):
    def __init__(self,
                 name:str,
                 maxsize:int=None,
                 dtype:type=None,
                 data_validator:Callable[[Any], bool]=None,
                 ):
        BaseInputPort.__init__(self, name, dtype, data_validator)
        DequePacketContainer.__init__(self, maxsize)

    def load(self, packet):
        self._check_packet_dtype(packet)
        super().load(packet)
        
    def load_left(self, packet):
        self._check_packet_dtype(packet)
        super().load_left(packet)
    
    async def receive_all(self):
        await self.empty.wait(False)
        packets = DequePacketContainer.unload_all(self)
        packet_datas = [await packet.get_data() for packet in packets]
        for packet_data in packet_datas:
            self._validate_packet_data(packet_data)
        self._empty_ports += list(self._filled_ports)
        self._filled_ports.clear()
        self._update_status_events()
        return packet_datas
        
    async def receive(self):
        await self.empty.wait(False)
        packet = DequePacketContainer.unload(self)
        packet_data = packet.get_data()
        if inspect.isawaitable(packet_data): packet_data = await packet_data
        self._validate_packet_data(packet_data)
        return packet_data
    
    async def receive_right(self):
        await self.empty.wait(False)
        packet = DequePacketContainer.unload(self)
        packet_data = packet.get_data()
        if inspect.isawaitable(packet_data): packet_data = await packet_data
        self._validate_packet_data(packet_data)
        return packet_data

# %% ../nbs/api/ports.ipynb 19
class BaseOutputPort(BasePort, PacketContainer):
    def __init__(self,
                 name:str,
                 dtype:type=None,
                 data_validator:Callable[[Any], bool]=None):
        super().__init__(name, dtype, data_validator)

    def load(self, packet):
        raise NotImplementedError("`load` is disabled for output ports.")
    
    @abstractmethod
    async def put(self,
            packet_data):
        raise NotImplementedError()

# %% ../nbs/api/ports.ipynb 21
class SingleOutputPort(BaseOutputPort, SinglePacketContainer):
    def __init__(self,
                 name:str,
                 dtype:type=None,
                 data_validator:Callable[[Any], bool]=None):
        BaseOutputPort.__init__(self, name, dtype, data_validator)
        SinglePacketContainer.__init__(self)
    
    async def put(self, packet_data):
        await self.full.wait(False)
        packet = Packet(packet_data)
        self._validate_packet_data(packet_data)
        self._check_packet_data_dtype(packet_data)
        SinglePacketContainer.load(self, packet)

# %% ../nbs/api/ports.ipynb 24
class DequeOutputPort(BaseOutputPort, DequePacketContainer):
    def __init__(self,
                 name:str,
                 maxsize:int=None,
                 dtype:type=None,
                 data_validator:Callable[[Any], bool]=None,
                 ):
        BaseOutputPort.__init__(self, name, dtype, data_validator)
        DequePacketContainer.__init__(self, maxsize)

    def load_right(self):
        raise NotImplementedError("`load_right` is disabled for output ports.")
    
    async def put(self, packet_data):
        await self.full.wait(False)
        packet = Packet(packet_data)
        self._validate_packet_data(packet_data)
        self._check_packet_data_dtype(packet_data)
        DequePacketContainer.load(self, packet)
        
    async def put_left(self, packet_data):
        await self.full.wait(False)
        packet = Packet(packet_data)
        self._validate_packet_data(packet_data)
        self._check_packet_data_dtype(packet_data)
        DequePacketContainer.load_left(self, packet)
